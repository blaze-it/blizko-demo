generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// Auth Models (BetterAuth)
// ============================================================================

model User {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  email           String   @unique
  name            String?
  username        String?  @unique
  displayUsername  String?  @unique
  emailVerified   Boolean  @default(false)
  neighborhood    String?
  bio             String?

  // Stripe Connect
  stripeCustomerId  String?   @unique
  stripeAccountId   String?   @unique
  stripeOnboarded   Boolean   @default(false)

  sessions          Session[]
  accounts          Account[]
  image             UserImage?
  password          Password?
  roles             Role[]
  organizedEvents   Event[]              @relation("EventOrganizer")
  eventParticipants EventParticipant[]
  reviewsWritten    Review[]             @relation("ReviewsWritten")
  payments          Payment[]
  payouts           Payout[]
  followers         Follow[]             @relation("Following")
  following         Follow[]             @relation("Followers")
  notifications     Notification[]
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Verification {
  id         String    @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt
}

model UserImage {
  id          String @id @default(cuid())
  contentType String
  blob        Bytes
  userId      String @unique

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Password {
  hash   String
  userId String @unique

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Role {
  id          String       @id @default(cuid())
  name        String       @unique
  users       User[]
  permissions Permission[]
}

model Permission {
  id     String @id @default(cuid())
  entity String
  action String
  access String
  roleId String

  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
}

// ============================================================================
// Events Platform Models
// ============================================================================

model Event {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  title           String
  description     String
  category        EventCategory
  date            DateTime
  startTime       String
  endTime         String?
  durationMinutes Int?
  locationName    String
  address         String
  latitude        Float
  longitude       Float
  price           Int           @default(0)
  currency        String        @default("CZK")
  capacity        Int
  status          EventStatus   @default(DRAFT)
  imageUrl        String?
  organizerId     String

  organizer    User               @relation("EventOrganizer", fields: [organizerId], references: [id], onDelete: Cascade)
  participants EventParticipant[]
  reviews      Review[]
  payments     Payment[]
  payouts      Payout[]
}

model EventParticipant {
  id        String            @id @default(cuid())
  createdAt DateTime          @default(now())
  status    ParticipantStatus @default(CONFIRMED)
  eventId   String
  userId    String

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
}

model Review {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  rating     Int      // 1-5
  comment    String?
  eventId    String
  reviewerId String

  event    Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  reviewer User  @relation("ReviewsWritten", fields: [reviewerId], references: [id], onDelete: Cascade)

  @@unique([eventId, reviewerId])
}

// ============================================================================
// Enums
// ============================================================================

enum EventCategory {
  WORKOUT
  WORKSHOP
  KIDS
  MEETUP
  LECTURE
  LEISURE
  OTHER
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
}

enum ParticipantStatus {
  CONFIRMED
  CANCELLED
  WAITLISTED
}

// ============================================================================
// Payment Models
// ============================================================================

model Payment {
  id                    String        @id @default(cuid())
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  amount                Int
  currency              String        @default("CZK")
  status                PaymentStatus @default(PENDING)
  stripePaymentIntentId String?       @unique
  stripeSessionId       String?       @unique
  eventId               String
  userId                String

  event   Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
}

model Payout {
  id               String       @id @default(cuid())
  createdAt        DateTime     @default(now())
  amount           Int
  currency         String       @default("CZK")
  status           PayoutStatus @default(PENDING)
  stripeTransferId String?      @unique
  organizerId      String
  eventId          String?

  organizer User   @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  event     Event? @relation(fields: [eventId], references: [id], onDelete: SetNull)
}

enum PaymentStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  REFUNDED
}

enum PayoutStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
}

// ============================================================================
// Social Models
// ============================================================================

model Follow {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  followerId  String
  followingId String

  follower  User @relation("Followers", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
}

model Notification {
  id        String           @id @default(cuid())
  createdAt DateTime         @default(now())
  type      NotificationType
  title     String
  body      String
  data      Json?
  read      Boolean          @default(false)
  userId    String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum NotificationType {
  NEW_FOLLOWER
  EVENT_FROM_FOLLOWING
  EVENT_REMINDER
  EVENT_CANCELLED
  EVENT_UPDATED
  PAYMENT_CONFIRMED
  REVIEW_RECEIVED
}
